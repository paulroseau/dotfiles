## TreeSitter concepts

- TreeSitter is a CLI tool written in Rust, and C library which can be imported in other languages (bindings).

- The cli tool allows you to generate parsers (`.so` libararies) from grammar files written in Javascript. You need to define one grammar for each programming language.

- The TreeSitter C library defines a tree structure to represent any source file.

- It creates the tree structure based on the parsers library generated from the language grammar files.

- It can efficiently update the tree as the source file gets updated.

- It defines a query lisp language which allows to specify groups of nodes in the tree (example: all the function names, all the arguments, etc.).

- In terms of C objects, here is what the documentation says:
  - There are 4 main types of objects involved when using Tree-sitter: languages, parsers, syntax trees, and syntax nodes. In C, these are called `TSLanguage`, `TSParser`, `TSTree`, and `TSNode`.
  - A `TSLanguage` is an opaque object that defines how to parse a particular programming language. The code for each `TSLanguage` is generated by Tree-sitter. Many languages are already available in separate git repositories within the Tree-sitter GitHub organization.
  - A `TSParser` is a stateful object that can be assigned a `TSLanguage` and used to produce a `TSTree` based on some source code.
  - A `TSTree` represents the syntax tree of an entire source code file. It contains `TSNode` instances that indicate the structure of the source code. It can also be edited and used to produce a new `TSTree` in the event that the source code changes.
  - A `TSNode` represents a single node in the syntax tree. It tracks its start and end positions in the source code, as well as its relation to other nodes like its parent, siblings and children.

## TreeSitter in nvim

- The `treesitter` C library is included in `nvim` (cf. nix code), and in the `nvim` source code you can see it imports the `tree_sitter/api.h` header which is in the `lib/include/tree_sitter/api.h` in tree sitter source code. The tree sitter functions are added to the lua environment in `lua/executor.c` as well.

- At build time, default parsers (for C, vimscript, vimdoc and lua languages) are compiled and added to `$VIMRUNTIME/parsers`. Check `preConfigure` in `neovim/default.nix`:
  ```lua
  lib.concatStrings (lib.mapAttrsToList
    (language: src: ''
      ln -s \
        ${tree-sitter.buildGrammar {
          inherit language src;
          version = "neovim-${version}";
        }}/parser \
        $out/lib/nvim/parser/${language}.so
    '')
    treesitter-parsers);
  ```
  The `treesitter-parsers` argument could allow you to include more built-in parsers through nix.

- Inside `lua/treesitter.c` wrapping C functions around the tree_sitter library functions are defined, and some of those are added to the lua_state inside `lua/executor.c` such as `vim._ts_parse_query` for example. These functions are available in lua in `nvim`, but should not be used directly. Instead in the `$VIMRUNTIME/lua/treesitter.lua` a propper `vim.treesitter` module is defined which underneath calls those lowerlevel `vim._ts_xxx` functions (for example `vim._ts_has_language(lang)` is called in `$VIMRUNTIME/lua/treesitter/language.lua`).

- Highlighting logic is defined in `$VIMRUNTIME/lua/treesitter/highlighter.lua`, it basically finds the `highlight.scm` TreeSitter query and set the flag `vim.b[self.bufnr].ts_highlight = true` (this buffer local variable is checked by the autocommand defined in `$VIMRUNTIME/syntax/syntax.vim` cf. lower). This means that the `syntax` buffer local option is not set when the TreeSitter Highlighter is running, which means that the default syntax file present in `$VIMRUNTIME/syntax` would not be run. 

- To run TreeSitter highlighting, the api is simply `vim.treesitter.start()`, which instantiate a TreeSitterHighlighter:
  ```lua
  function M.start(bufnr, lang)
    bufnr = bufnr or a.nvim_get_current_buf()
    local parser = M.get_parser(bufnr, lang)
    M.highlighter.new(parser)
  end
  ```
  As the comment above that function specifies, if you also want to source `$VIMRUNTIME/syntax/<filetype>.vim` you can wrap `vim.treesitter.start()` in an autocommand on FileType event, and set the syntax buffer option after (which will trigger the `Syntax` event and source the file you want):
  ```lua
  vim.api.nvim_create_autocmd( 'FileType', { pattern = 'tex',
      callback = function(args)
          vim.treesitter.start(args.buf, 'latex')
          vim.bo[args.buf].syntax = 'on'  -- only if additional legacy syntax is needed
      end
  })
  ```
  This is exactly what the nvim-treesitter plugin allows you to do (cf. lower)

## Note on nvim filetypes, syntax and colorscheme

### Filetypes

- If `set filetype` is on then the `$VIMRUNTIME/filetype.lua` is sourced, which creates an autocommand on `BufRead` (and other events) which detects the type of the file with `ft = vim.filetype.match(...)` and sets it with `vim.api.nvim_cmd({ cmd = 'setf', args = { ft } }, {})`. I guess that `setf` triggers the `FileType` event (that is probably builtin).

- When the filetype is set (either through `setlocal filetype=...` or with `setfiletype`) the `FileType` event is fired and autocommands set on this event are triggered.

- If `set filetype plugin` is on, then the `$VIMRUNTIME/ftplugin.vim` file is sourced, which creates an autocommand on the `FileType` event to source the files under `./ftplugin/<pattern>.vim` in the rtp where pattern is the value of the filetype (something like `exe 'runtime! ftplugin/' . name . '.lua'`)

- The pattern argument in an autocommand defined on the `FileType` event is the name of the filetype (not a pattern such as `*.c`).

### Indent

- The same mechanism is used for `indent`. `set indent` will source `$VIMRUNTIME/indent.vim` which will set an autocommand on `FileType` which will load the corresponding indent file for this filetype: `exe 'runtime! indent/' . name . '.lua'`

- Note that for indentation, there are 4 options which override one another (from the simplest to the most complex), from `:help indent.txt`:
  ```
  There are in fact four main methods available for indentation, each one overrides the previous if it is enabled, or non-empty for 'indentexpr':
  'autoindent'	uses the indent from the previous line.
  'smartindent'	is like 'autoindent' but also recognizes some C syntax to increase/reduce the indent where appropriate.
  'cindent'	Works more cleverly than the other two and is configurable to different indenting styles.
  'indentexpr'	The most flexible of all: Evaluates an expression to compute the indent of a line. When non-empty this method overrides the other ones. See indent-expression.
  ```

### Colorscheme

- When running `set colorscheme <name>`, `$VIMRUNTIME/colors/<name>.[vim|lua]` will be sourced. Colorscheme files typically contain a set of `highlight` commands which specify how to highlight (color/style) particular groups. For instance:
```vim
hi Comment	gui=bold
```
will result in displaying in bold all elements spotted as comments. Note that this just adds to the default settings already in place for that particular highlight group.

- These highlight groups are traditionnally defined through `syntax match` or `syntax region` commands. For instance in the `markdown.vim` file, the `markdownBlockquote` group is defined, and it is instructed to highlight it like comments through the `highlight def link` command:
```vim
...
syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
...
hi def link markdownBlockquote            Comment
...
```

- The purpose of a colorscheme file is to define a nice color palette and assign colors to the built-in highlight groups.

- Tree-sitter capture groups are usable as highlight groups (ie. treesitter-nvim defines group for those) and are linked to neovim default group (cf. `help treesitter-highlight-groups`)

- Note that some colorschemes (for example the `default` one) will refer to some variable colors which will change if the you change the value of `backgroud` to `dark/light`. This is not the case for all of them (test with `set colorscheme blue`). Also some colorscheme don't define the background color (for example the `default` one) which then results in using the terminal default color.

- Some colorschemes plugin are available online, they define a `colors/theme.{vim|lua}` file (which may refer to other files where they define palettes etc. to separate things neatly, check the https://github.com/navarasu/onedark.nvim for example). You can just include those in your RTP, and then you will be able to set them with `:set colorscheme
my-theme` or `vim.api.nvim_command('colorscheme my-theme')`.

### Common remark on Indent and Filetype

- In the initialization sequence, `runtime! ftplugin.vim` and `runtime! indent.vim` are run before the `init.lua` is sourced. However these files just set hooks on the `Filetype` events. Filetype events will fired only if `set filetype` is on which can be set or unset in the `init.lua` The `runtime! filetype.vim` is as part of the initialization sequence after the `init.lua` file is sourced. That being said there is still the command `unset filetype plugin` which will cause `runtime! ftplugoff.vim` which will destroy the autocommand groups set by `runtime! filetype.vim`. You can also reenable it afterwards with the same `set filetype plugin`. By default filetypes are sourced though as part of step 6. of the initialization.

### Syntax

- In neovim the `set syntax` is an alias to sourcing `$VIMRUNTIME/syntax/syntax.vim`.

- Syntax works the same as filetype. When `setlocal syntax=...` is run, the `Syntax` event is fired. When setting `set syntax=on` on startup, `$VIMRUNTIME/syntax/syntax.vim` is sourced, which does 3 things:
  1. it sources `$VIMRUNTIME/syntax/synload.vim` which registers autocommands on the `Syntax` event to source the corresponding syntax file for the syntax selected with `exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"`
  2. it runs `filetype on` if not done already, hence `set syntax=on` implies `filetype` to be on
  3. it creates an autocommand on the `FileType` event to set syntax appropriately when the filetype is detected if tree sitter is not enabled !
  ```lua
  au! FileType *	if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
  ```
  As a result, setting the filetype, will trigger `FileType` event, which will set the syntax, triggering the `Syntax` event, which will source the files which create highlighting groups.

## Tree sitter nvim plugin

- Source: https://github.com/nvim-treesitter/nvim-treesitter

- The neovim treesitter plugins allows you to:
  - download extra grammar files that are not builtin in neovim and compile them into `.so` parsers (you need to have `tree-sitter`, `npm` and `gcc` in your `$PATH` for this to work)
  - defines a `module` abstraction which is an object with an `attach()` and `detach()` functions in particular. When a module is enabled, its `attach()` is placed inside a FileType autocommand, so it is called when the filetype of a buffer is set.
  - initialization is done in `config.init()` which calls `config.define_modules()` which calls `config.enable_mod_conf_autocmd()`
  - defines 4 builtin modules:
    - syntax highlighting: the `attach` function runs `vim.treesitter.start()` which enables highlighting
    - indentation: the `attach` function runs `vim.bo.indentexpr = "nvim_treesitter#indent()"` which is a function defined `autoload` as `luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))`
    - folding: this is not a module because the foldexpr is a window option (not a buffer option - whatever), so you need to set it yourself as per documentation
    - incremental selection: the `attach` function defines mapping to select a TS Node, then its parent, recursively

- The code features `./lua`, `./plugin`, `./autoload` folders amongst others.

- The plugin is setup automatically through the `./plugin` folder which runs the `require("nvim-treesitter").setup()`. This calls the `config.init()` which enables the modules which are marked as enabled and defines an autocommand (inside an augroup) to reloads files with filetype `query` (tree sitter query files) when they are edited.

- NB: you can check that the filetype is properly recognized with `:lua vim.pretty_print(vim.filetype.match({ buf = 39 }))` after opening a query file in the buffer.

- If you don't specify `ensure_installed` and `auto_install` then the plugin won't download and compile parsers for you.

- Note that the `vim.treesitter.start()` function which is built into `nvim` disables syntax highlighting by default, so the `nvim-treesitter` plugin does not need to do `set nosyntax` prior to invoking it. cf. `nvim/runtime/lua/vim/treesitter/highlighter.lua`:

```lua
function TSHighlighter.new(tree, opts)
...
  vim.bo[self.bufnr].syntax = ''
  vim.b[self.bufnr].ts_highlight = true
...
end
```
